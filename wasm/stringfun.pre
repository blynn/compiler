infixr 9 .;
infixl 4 <*> , <$> , <* , *>;
infixl 1 >> , >>=;

class Functor f where { fmap :: (a -> b) -> f a -> f b };
class Applicative f where
{ pure :: a -> f a
; (<*>) :: f (a -> b) -> f a -> f b
};
class Monad m where
{ return :: a -> m a
; (>>=) :: m a -> (a -> m b) -> m b
};

instance Applicative IO where { pure = ioPure ; (<*>) f x = ioBind f \g -> ioBind x \y -> ioPure (g y) };
instance Monad IO where { return = ioPure ; (>>=) = ioBind };
instance Functor IO where { fmap f x = ioPure f <*> x };

ffi "putchar" putChar :: Char -> IO ();
ffi "getchar" getChar :: IO Int;

(<$>) = fmap;
liftA2 f x y = f <$> x <*> y;
(>>) f g = f >>= \_ -> g;
(.) f g x = f (g x);
flip f x y = f y x;
(==) = intEq;
(<=) = intLE;
flst xs n c = case xs of { [] -> n; h:t -> c h t };
foldr c n l = flst l n (\h t -> c h(foldr c n t));
map = flip (foldr . ((:) .)) [];
mapM_ f = foldr ((>>) . f) (pure ());

getContents = getChar >>= \n -> if n == 4294967295 then pure [] else (chr n:) <$> getContents;

interact f = f <$> getContents >>= mapM_ putChar;

fun _ = "Hello, World!";
